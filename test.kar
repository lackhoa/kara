(load "io.kar")

(stdisplay-n "Defining and retrieving a variable => 5")
(def a 5)
a

(stdisplay-n "Definition of code => 16")
(def (foo x) (+ x 11))
(foo a)

(stdisplay-n "If true => 1")
(if #t 1 2)

(stdisplay-n "If false => 2")
(if #f 1 2)

(stdisplay-n "If no else => 5")
(seq (def const 5) (if #f (def const 6) const))

(stdisplay-n "Conditional first => 1")
(cond [#t 1] [#f 2] [else 3])

(stdisplay-n "Conditional second => 5")
(cond (#f 1) (#t (def a 5) a) (else 3))

(stdisplay-n "Conditional else => 3")
(cond [#f 1] [#f 2] [else 3])

(stdisplay-n "Conditional without else => #f")
(cond (#f 1) (#f 2))

(stdisplay-n "When => 89")
(when #t (def a 89) a)

(stdisplay-n "Apply complex primitive procedure => 12")
(+ (+ 2 8) 2)

(stdisplay-n "Constant function => z")
((const 'z))

(stdisplay-n "Sequence in lambda => 9")
((lambda (z) (def z (+ z 6)) z) 3)

(stdisplay-n "Apply compound procedure => 15")
((lambda (x y) (+ x y)) 7 8)

(stdisplay-n "Using rest argument in `define` => (1 2 3 4)")
(def (my-list . x) x)
(my-list 1 2 3 4)

(stdisplay-n "Using rest argument in `lambda` => (4 3 2 1)")
((lambda x x) 4 3 2 1)

(stdisplay-n "Using both positional and rest argument in `define` => (1 2 3 4 5 6)")
(def (cons-list i . L) (cons i L))
(cons-list 1 2 3 4 5 6)

(stdisplay-n "Using both positional and rest argument in `lambda` => (6 5 4 3 2 1)")
((lambda (i . L) (cons i L)) 6 5 4 3 2 1)


(stdisplay-n "Store procedure and use them later => 10")
(def add3 (lambda ($) (+ 3 $)))
(add3 7)

(stdisplay-n "map procedure => (3...8)")
(map add3 (list 0 1 2 3 4 5))

(stdisplay-n "Sequencing => 36")
(seq (def x 9) (* x 4))

(stdisplay-n "Factorial => 6")
(def fact (lambda (n) (if (= n 1) 1 (* (fact (- n 1)) n))))
(fact 3)

(stdisplay-n "Environment request => all keys")
(hash-keys (car (meta-env)))

(stdisplay-n "Primitive => 8")
(! '(let ((x 5)) (+ 3 x)))

(stdisplay-n "Quasiquotation1 => (10 (18 18) 72)")
(def a 9)
'(10 (18 ,(+ 9 a)) ,(+ (* 8 8) 8))

(stdisplay-n "Quasiquotation2 => (10 '(18 20) 72)")
(def b 11)
'(10 '(18 ,,(+ 9 b)) ,(+ (* 8 8) 8))

(stdisplay-n "Quasiquotation2 => (10 '(18 ,(+ 9 a)) 72)")
'(10 '(18 ,(+ 9 a)) ,(+ (* 8 8) 8))

(stdisplay-n "String formating => Hi mom and dad")
(format "Hi ~s and ~s" 'mom 'dad)

(stdisplay-n "Tracing => fibonacci")
(def (fibo n)
    (cond
        [(= n 0) 1] [(= n 1) 1]
        [else (+ (fibo (- n 1)) (fibo (- n 2)))]))
(trace fibo)
(fibo 3)

(stdisplay-n "Delayed evaluation => 666")
(def a 8)
(def delayed (delay a))
(def a 666)
(force delayed)

(stdisplay-n "Inline forcing => 666")
(force (delay a))

(stdisplay-n "Lexical Scoping => 85, 80")
(def a 80)
(def (foo)
    (def a (+ a 5))
    a)
(foo)
a


; DANGER!!!
(stdisplay-n "The ultimate test of speed => some huge number")
(untrace fibo)
(fibo 20)






"All tests ran successfully (or at least it didn't crash)"
