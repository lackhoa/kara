; Constructor for set.
; Note that sequences are not in our model of types.
(def (Set seq)
     (def (reduce-aux x y)
        (if (in-seq? x y) y (cons x y)))

     (tag 'Set (reduce reduce-aux null seq)))

(def (empty-set? set)
     (case set [(Set ?s)
       (null? ?s)]))

; Concerned with efficiency? Change this function.
(def (in-set? x set)
     (case set
       [(Set ?sq) (in-seq? x ?sq)]))

(def (adjoin-set x set)
     (case set [(Set ?sq)
       (Set (cons x ?sq))]))

(def (intersection-set s1 s2)
     (if (or (empty-set? s1)
             (empty-set? s2))
         (Set null)
         (case s1 [(Set ?sq1)
            (seq
              (def s1-first (car ?sq1))
              (def s1-rest (Set (cdr ?sq1)))
              (if (in-set? s1-first s2)
                  ; Includes s1-first
                  (case (intersection-set s1-rest s2)
                      [(Set ?irs)
                       (Set (cons s1-first ?irs))]) 
                  ; Doesn't include s1-first
                  (intersection-set s1-rest s2)))])))

; You can switch s1 and s2 and this function would still work.
(def (union-set s1 s2)
   (case s1 [(Set ?sq1)
     (case s2 [(Set ?sq2)
       (Set (append ?sq1 ?sq2))])]))






