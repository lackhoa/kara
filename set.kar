; Constructor for set.
; Note that sequences are not in our model of types.
(def (seq->set seq)
     (def (reduce-aux x y)
        (if (in-seq? x y) y (cons x y)))
     (tag 'Set (reduce reduce-aux null seq)))

(def (empty-set? set)
     (case set
       [(Set ?s) (null? ?s)]))

; Concerned with efficiency? Change this function.
(def (in-set? x set)
     (case set
       [(Set ?sq) (in-seq? x ?sq)]))

(def (adjoin-set x set)
     (case set
       [(Set ?sq) (if (in-seq? x ?sq)
                      set
                      (tag 'Set (cons x ?sq)))]))


(def (intersection-set s1 s2)
  (def (intersection-set-core sq1 sq2)
     (if (or (null? sq1) (null? sq2))
         null
         (seq
           (def sq1-first (car sq1))
           (def sq1-rest (cdr sq1))
           (if (in-seq? sq1-first sq2)
               ; Includes sq1-first
               (cons sq1-first (intersection-set-core sq1-rest sq2)) 
               ; Doesn't include sq1-first
               (intersection-set-core sq1-rest sq2)))))

  (case s1 [(Set ?sq1)
    (case s2 [(Set ?sq2)
      (tag 'Set (intersection-set-core ?sq1 ?sq2))])]))

; You can switch s1 and s2 and this function would still work.
(def (union-set s1 s2)
   (case s1 [(Set ?sq1)
     (case s2 [(Set ?sq2)
       (tag 'Set (append ?sq1 (filter (lam (x)
                                        (not (in-seq? x ?sq1)))
                                      ?sq2)))])]))






