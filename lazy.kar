(load "io.kar")

; params: $stream
(set! stream-car '((car $0)))

; params: $stream
(set! stream-cdr '((cadr $0)))

; params: $(the function evaluating to the first value)
;         $(the function evaluating to the rest of the stream (a stream-generating function))
; This is the only stream constructor.
(set! stream-cons ''(,$0 ,$1))

(set! empty-stream '())

(set! stream-null? '(null? $0))

; params: $stream, $index
(set! stream-ref
    '(if (= $1 0)
         (stream-car $0)
         (stream-ref (stream-cdr $0) (- $1 1))))





; -----------------------------------------------
; Complex functions
; -----------------------------------------------

; params: $stream1, $stream2
(set! glue
    '(if (stream-null? $0)
         $1
         (stream-cons '(stream-car ',,$0)
                      '(glue (stream-cdr ',,$0) ',,$1))))

; params: $(A non-empty stream of streams)
(set! glue*
    '(if (stream-null? (stream-cdr $0))
         (stream-car $0)
         (glue (stream-car $0) (glue* (stream-cdr $0)))))

; params: func, $stream
; returns: a stream
(set! stream-map
    '(if (stream-null? $0)
         empty-stream
         (stream-cons '(',,func (stream-car ',,$0))
                      '(stream-map (~ func ',,func) (stream-cdr ',,$0)))))

; params: func, $stream
; strictly for side-effects
(set! stream-mapfx
    '(if (stream-null? $0)
         'done
         (seq (func (stream-car $0))
              (stream-mapfx (stream-cdr $0)))))

(set! print-stream '(stream-mapfx $0 (~ func '(stdisplay-n $0))))

; params: $low, $high
(set! range
    '(if (> $0 $1)
         empty-stream
         (stream-cons ',$0 '(range ,(+ 1 $0) ,$1))))

; params: $(a list of streams)
; returns: a stream of lists
(set! stream-product '(seq
    (set! L $0) (set! first (car L)) (set! rest (cdr L))
    (if (null? rest)
        ; Base case: a stream of lists containing single items in first
        (stream-map (~ func ''(,$0)) first)
        ; Recursive case:
        (seq
            (set! prod-rest (stream-product rest))
            ; prod-rest is a stream
            (set! to-be-glued
                (stream-map first
                    (~ func '(seq
                        (set! iter-first $0)
                        (stream-map ',,prod-rest (~ func '(cons ',,iter-first $0)))))))
            (glue* to-be-glued)))))

; Testing
(set! new-range (range 5 10))
(stdisplay-n "=> 10")
(stream-ref new-range 5)

(stdisplay-n "Mapping 0 => 81")
(stream-ref (stream-map (~ func '(* $0 $0)) new-range) 4)

(stdisplay-n "Mapping 1 => squares")
(print-stream (stream-map (~ func '(* $0 $0)) new-range))

(stdisplay-n "Mapping 2 => #t")
(stream-car (stream-cdr (stream-map (~ func odd?) (range 10000 1000000))))

(stdisplay-n "=> Infinite integers => 100")
(set! inf-range '(stream-cons $0 '(inf-range (+ ,$0 1))))
(stream-ref (inf-range 1) 99)

(stdisplay-n "Stream of sixes => 6")
(set! sixes (stream-cons '6 'sixes))
(stream-ref sixes 6)

(stdisplay-n "Double => 16")
(set! scale-stream '(stream-map (~ func '(* $0 ,factor)) $0))
(set! double (stream-cons '1 '(scale-stream double (~ factor 2))))
(stream-ref double 4)

(stdisplay-n "Glue streams: 1 -> 4, 11 -> 14")
(print-stream (glue (range 1 4) (range 11 14)))

(stdisplay-n "Glue more streams: 1 -> 4, 11 -> 14, 21 -> 24")
(set! intermediate (stream-cons '(range 11 14) '(stream-cons '(range 21 24) ''())))
(set! stream-of-streams (stream-cons '(range 1 4) 'intermediate))
(print-stream (glue* stream-of-streams))

(stdisplay-n "=> I don't know what to expect right now")
; (set! ingredient '(,(range 1 4)))
(set! ingredient '(,(range 1 4) ,(range 2 5) ,(range 10 11)))
(print-stream (stream-product ingredient))
