(load "io.kar")

; This file focuses on the lazy way of working with sequences
; The terminology is like this (although it's too late to establish):
; Sequence = List + Stream 
; Stream = Lazy
; List = Strict

; -----------------------------------------------
; Foundation of the Stream Paradigm
; -----------------------------------------------

; This is the only stream constructor (same one used for strict list)
; param first-promise: (the promise of the first value)
; param rest-promise: (the promise of the rest of the stream)
; (def (cons first-promise rest-promise)
;     (cons first-promise rest-promise))

; Forces the promise of the first value.
(def (fcar stream)
    (force (car stream)))

; Forces the promise of the other values.
(def (fcdr stream)
    (force (cdr stream)))

; The empty stream is represented as the empty list.
; It is a unique value, not even the delayed empty list is equal
(def empty-stream '())

; list-ref must be re-design since the one in Racket
; is random-access
(def (stream-ref stream index)
    (cond [(null? stream) "Out of bound"]
          [(= index 0) (fcar stream)]
          [else (stream-ref (fcdr stream)
                            (- index 1))]))

; The idea is like mapfx, but doesn't mix up the order
(def (for-each proc s)
    (if (null? s)
        'done
        (seq (proc (fcar s))
             (for-each proc (fcdr s)))))

(def (display-stream stream)
    (for-each stdisplay-n stream))

; -----------------------------------------------
; Useful functions
; -----------------------------------------------

; The most important stream function
(def (reduce op init stream)
    (if (null? stream)
        init
        (op (fcar stream)
            (reduce op init (fcdr stream)))))

(def (filter pred stream)
    (reduce (lam (x y)
                (if (pred x) (cons x y) y))
            null
            stream))

; Really?
(def (stream-append seq1 seq2)
    (reduce cons seq2 seq1))

; Mapping and reducing with stream-append to create nested maps
(def (flatmap proc seq)
    (reduce stream-append null (map proc seq)))

(def (remove x s)
    (filter (lam (item) (not (eq? item x)))
            s))

(def (permutations s)
    ; This function sticks the x to the permutations that doesn't contain x
    (def (permute-aux x)
        (map (lam (p) (cons x p))
            (permutations (remove x s))))

    ; Main job done here
    (if (null? s)
        (list null)  ; Sequence containing empty set
        (flatmap permute-aux s)))

(def (stream->list stream)
    (reduce cons null stream))

(def (length sequence)
    (reduce (lam (x y) (+ 1 y)) 0 sequence))

(def (range lower upper)
    (if (> lower upper)
        null
        (cons lower
              (delay (range (+ 1 lower) upper)))))

(def (map func L)
    (reduce (lam (x y)
                 (cons (func x) y))
            null
            L))

(def (wrap thing)
    (list thing))

; params: streams (a list of streams to take product).
; returns: a stream of strict lists as products
(def (product streams)
    ; The algorithm of the reduce
    (def (prod-aux first prod-rest)
        (flatmap (lam (iter-first)
                      (map (lam (iter-prod-rest)
                               (cons iter-first iter-prod-rest))
                           prod-rest))
                 first))

    (reduce prod-aux
            (list null)  ; Base case: kind of undefined?
            streams))


; params s: a single sequence as a set
;           (although not guaranteed by the algorithm).
; returns: a stream of list as subsets of the given set
(def (powerset s)
    (def (pow-aux first pow-rest)
         (append (map (lam (pow-rest-iter)
                          (cons first pow-rest-iter))
                      pow-rest) ; Include first
                 pow-rest))     ; Exclude first

    (reduce pow-aux
            (list null)  ; Base case: the only subset of the empty set is itself
            s))
